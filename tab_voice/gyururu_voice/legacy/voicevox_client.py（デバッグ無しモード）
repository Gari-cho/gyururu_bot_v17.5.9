#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸ¤ VOICEVOX API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
éåŒæœŸéŸ³å£°åˆæˆãƒ»è©±è€…ç®¡ç†ãƒ»æ¥ç¶šç›£è¦–

Features:
âœ… å®Œå…¨éåŒæœŸ aiohttp ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
âœ… æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ãƒªãƒˆãƒ©ã‚¤
âœ… è©±è€…æƒ…å ±ç®¡ç†ãƒ»ã‚«ãƒ†ã‚´ãƒªåˆ†é¡
âœ… é«˜å“è³ªéŸ³å£°åˆæˆè¨­å®š
âœ… æ¥ç¶šç›£è¦–ãƒ»è‡ªå‹•å¾©æ—§
"""

import asyncio
import aiohttp
import json
import time
from collections import defaultdict
from datetime import datetime
from typing import Dict, Any, Optional, List, Tuple

from .config import VoiceSettings, SystemConfig, SpeakerInfo

try:
    from gyururu_utils.logger import get_gui_logger
    logger = get_gui_logger(__name__)
except ImportError:
    import logging
    logger = logging.getLogger(__name__)

class VOICEVOXClient:
    """
    VOICEVOX APIéåŒæœŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
    éŸ³å£°åˆæˆãƒ»è©±è€…ç®¡ç†ãƒ»æ¥ç¶šç›£è¦–ã‚’çµ±åˆ
    """
    
    def __init__(self, voicevox_url: str, voice_settings: VoiceSettings, system_config: SystemConfig):
        """åˆæœŸåŒ–"""
        self.voicevox_url = voicevox_url.rstrip('/')
        self.voice_settings = voice_settings
        self.system_config = system_config
        
        # === æ¥ç¶šçŠ¶æ…‹ ===
        self.available = False
        self.version = None
        self.last_connection_check = 0
        self.connection_retries = 0
        
        # === è©±è€…ç®¡ç† ===
        self.speakers: Dict[int, SpeakerInfo] = {}
        self.speaker_categories: Dict[str, List[int]] = defaultdict(list)
        self.speakers_loaded = False
        
        # === ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç† ===
        self.session: Optional[aiohttp.ClientSession] = None
        self._session_lock = asyncio.Lock()
        
        # === çµ±è¨ˆãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ ===
        self.synthesis_count = 0
        self.synthesis_errors = 0
        self.synthesis_times = []
        self.error_history = []
        
        logger.info(f"ğŸ¤ VOICEVOX ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–: {self.voicevox_url}")
    
    async def initialize_async(self) -> bool:
        """éåŒæœŸåˆæœŸåŒ–"""
        try:
            # ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ
            await self._ensure_session()
            
            # æ¥ç¶šç¢ºèª
            connection_success = await self.check_connection()
            if connection_success:
                # è©±è€…æƒ…å ±èª­ã¿è¾¼ã¿
                await self.load_speakers()
            
            return connection_success
            
        except Exception as e:
            logger.error(f"âŒ VOICEVOX ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def _ensure_session(self) -> None:
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¢ºä¿"""
        async with self._session_lock:
            if self.session is None or self.session.closed:
                timeout = aiohttp.ClientTimeout(
                    total=self.system_config.get("synthesis_timeout", 30)
                )
                self.session = aiohttp.ClientSession(
                    timeout=timeout,
                    connector=aiohttp.TCPConnector(limit=10, limit_per_host=5)
                )
                logger.debug("ğŸ”— VOICEVOX HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆå®Œäº†")
    
    async def check_connection(self) -> bool:
        """æ¥ç¶šç¢ºèªï¼ˆæŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•å¯¾å¿œï¼‰"""
        max_attempts = self.system_config.get("retry_attempts", 3)
        
        for attempt in range(max_attempts):
            try:
                # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•è¨ˆç®—
                if attempt > 0:
                    delay = self.system_config.get("retry_delay", 1.0)
                    if self.system_config.get("retry_exponential_backoff", True):
                        delay = delay * (2 ** (attempt - 1))
                    await asyncio.sleep(delay)
                
                await self._ensure_session()
                
                # ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¢ºèª
                async with self.session.get(f"{self.voicevox_url}/version") as response:
                    if response.status == 200:
                        version_text = await response.text()
                        self.version = version_text.strip('"')
                        self.available = True
                        self.last_connection_check = time.time()
                        self.connection_retries = 0
                        
                        logger.info(f"âœ… VOICEVOXæ¥ç¶šæˆåŠŸ: {self.version}")
                        return True
                    else:
                        raise aiohttp.ClientError(f"HTTP {response.status}")
                        
            except Exception as e:
                self.connection_retries += 1
                if attempt == max_attempts - 1:
                    self.available = False
                    self.version = None
                    self._log_connection_error(e)
                    return False
                else:
                    logger.warning(f"âš ï¸ VOICEVOXæ¥ç¶šè©¦è¡Œ{attempt + 1}å¤±æ•—: {e}")
        
        return False
    
    def _log_connection_error(self, error: Exception) -> None:
        """æ¥ç¶šã‚¨ãƒ©ãƒ¼ãƒ­ã‚°"""
        error_msg = str(error).lower()
        if "connection refused" in error_msg:
            logger.error("âŒ VOICEVOXæ¥ç¶šæ‹’å¦ - VOICEVOXãŒèµ·å‹•ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
        elif "timeout" in error_msg:
            logger.error("âŒ VOICEVOXæ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¾ãŸã¯è² è·ã®å•é¡Œã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
        elif "name or service not known" in error_msg:
            logger.error("âŒ VOICEVOX URLãŒç„¡åŠ¹ã§ã™ - è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„")
        else:
            logger.error(f"âŒ VOICEVOXæ¥ç¶šã‚¨ãƒ©ãƒ¼: {error}")
    
    async def load_speakers(self) -> bool:
        """è©±è€…æƒ…å ±èª­ã¿è¾¼ã¿"""
        try:
            if not self.available:
                logger.warning("âš ï¸ VOICEVOXæ¥ç¶šæœªç¢ºç«‹ã®ãŸã‚è©±è€…èª­ã¿è¾¼ã¿ã‚¹ã‚­ãƒƒãƒ—")
                return False
            
            await self._ensure_session()
            
            async with self.session.get(f"{self.voicevox_url}/speakers") as response:
                if response.status != 200:
                    raise aiohttp.ClientError(f"è©±è€…æƒ…å ±å–å¾—å¤±æ•—: HTTP {response.status}")
                
                speakers_data = await response.json()
                
                # è©±è€…æƒ…å ±æ•´ç†
                self.speakers.clear()
                self.speaker_categories.clear()
                
                for speaker in speakers_data:
                    speaker_name = speaker.get("name", "Unknown")
                    speaker_uuid = speaker.get("speaker_uuid", "")
                    
                    for style in speaker.get("styles", []):
                        style_id = style.get("id")
                        style_name = style.get("name", "Normal")
                        full_name = f"{speaker_name} - {style_name}"
                        category = self._categorize_speaker(speaker_name)
                        
                        # SpeakerInfoä½œæˆ
                        speaker_info = SpeakerInfo(
                            id=style_id,
                            name=full_name,
                            speaker_name=speaker_name,
                            style_name=style_name,
                            speaker_uuid=speaker_uuid,
                            category=category
                        )
                        
                        self.speakers[style_id] = speaker_info
                        self.speaker_categories[category].append(style_id)
                
                self.speakers_loaded = True
                logger.info(f"ğŸ­ è©±è€…æƒ…å ±èª­ã¿è¾¼ã¿å®Œäº†: {len(self.speakers)}ç¨®é¡, {len(self.speaker_categories)}ã‚«ãƒ†ã‚´ãƒª")
                
                # ãã‚…ã‚‹ã‚‹éŸ³å£°ç¢ºèª
                await self._verify_gyururu_voice()
                
                return True
                
        except Exception as e:
            logger.error(f"âŒ è©±è€…æƒ…å ±èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            self.speakers_loaded = False
            return False
    
    def _categorize_speaker(self, speaker_name: str) -> str:
        """è©±è€…ã‚«ãƒ†ã‚´ãƒªåˆ†é¡"""
        name_lower = speaker_name.lower()
        
        # VOICEVOXç³»
        if any(keyword in name_lower for keyword in ["ãšã‚“ã ã‚‚ã‚“", "å››å›½ã‚ãŸã‚“", "æ˜¥æ—¥éƒ¨ã¤ã‚€ã", "å†¥é³´ã²ã¾ã‚Š"]):
            return "VOICEVOXæ¨™æº–"
        # ãã‚…ã‚‹ã‚‹ç³»
        elif any(keyword in name_lower for keyword in ["å°å¤œ", "sayo"]):
            return "ãã‚…ã‚‹ã‚‹ç³»"
        # COEIROINKç³»
        elif any(keyword in name_lower for keyword in ["ã¤ãã‚ˆã¿ã¡ã‚ƒã‚“", "æ˜æ—¥é¦™"]):
            return "COEIROINK"
        # ãƒœã‚¤ãƒ­ç³»
        elif any(keyword in name_lower for keyword in ["ç´è‘‰", "çµæœˆ", "ç´²æ˜Ÿ", "æ±åŒ—"]):
            return "ãƒœã‚¤ãƒ­"
        # å•†ç”¨ç³»
        elif any(keyword in name_lower for keyword in ["nemo", "ã‚¢ãƒªã‚¢ãƒ«"]):
            return "å•†ç”¨"
        else:
            return "ãã®ä»–"
    
    async def _verify_gyururu_voice(self) -> None:
        """ãã‚…ã‚‹ã‚‹éŸ³å£°ç¢ºèª"""
        gyururu_id = self.voice_settings.get("gyururu_voice_id", 46)
        if gyururu_id in self.speakers:
            speaker_info = self.speakers[gyururu_id]
            logger.info(f"âœ… ãã‚…ã‚‹ã‚‹éŸ³å£°ç¢ºèª: {speaker_info.name} (ID:{gyururu_id})")
        else:
            logger.warning(f"âš ï¸ ãã‚…ã‚‹ã‚‹éŸ³å£°ID {gyururu_id} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            # ä»£æ›¿éŸ³å£°ææ¡ˆ
            gyururu_category_speakers = self.speaker_categories.get("ãã‚…ã‚‹ã‚‹ç³»", [])
            if gyururu_category_speakers:
                alt_id = gyururu_category_speakers[0]
                alt_speaker = self.speakers[alt_id]
                logger.info(f"ğŸ’¡ ä»£æ›¿éŸ³å£°ææ¡ˆ: {alt_speaker.name} (ID:{alt_id})")
    
    async def synthesize_speech(self, text: str, voice_id: int) -> Optional[bytes]:
        """éŸ³å£°åˆæˆå®Ÿè¡Œ"""
        if not self.available:
            logger.warning("âš ï¸ VOICEVOXæ¥ç¶šæœªç¢ºç«‹ã®ãŸã‚éŸ³å£°åˆæˆã‚¹ã‚­ãƒƒãƒ—")
            return None
        
        if not text or not text.strip():
            logger.warning("âš ï¸ éŸ³å£°ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã§ã™")
            return None
        
        synthesis_start = time.time()
        
        try:
            await self._ensure_session()
            
            # éŸ³å£°è¨­å®šå–å¾—
            speed = self.voice_settings.get("speed", 100) / 100.0
            pitch = self.voice_settings.get("pitch", 100) / 100.0
            volume = self.voice_settings.get("volume", 70) / 100.0
            quality_mode = self.voice_settings.get("quality_mode", "high")
            
            # éŸ³å£°ã‚¯ã‚¨ãƒªä½œæˆ
            async with self.session.post(
                f"{self.voicevox_url}/audio_query",
                params={"text": text, "speaker": voice_id}
            ) as response:
                if response.status != 200:
                    error_text = await response.text()
                    raise aiohttp.ClientError(f"éŸ³å£°ã‚¯ã‚¨ãƒªä½œæˆå¤±æ•—: HTTP {response.status} - {error_text}")
                
                audio_query = await response.json()
            
            # é«˜å“è³ªè¨­å®šé©ç”¨
            audio_query["speedScale"] = speed
            audio_query["pitchScale"] = pitch
            audio_query["volumeScale"] = min(volume * 0.8, 0.8)  # å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³
            
            # å“è³ªãƒ¢ãƒ¼ãƒ‰è¨­å®š
            if quality_mode == "high":
                audio_query["prePhonemeLength"] = 0.1
                audio_query["postPhonemeLength"] = 0.1
            elif quality_mode == "fast":
                audio_query["prePhonemeLength"] = 0.05
                audio_query["postPhonemeLength"] = 0.05
            
            # ãƒã‚¤ã‚ºãƒªãƒ€ã‚¯ã‚·ãƒ§ãƒ³è¨­å®š
            if self.voice_settings.get("noise_reduction", True):
                sample_rate = self.voice_settings.get("sample_rate", 44100)
                audio_query["outputSamplingRate"] = sample_rate
            
            # éŸ³å£°åˆæˆå®Ÿè¡Œ
            async with self.session.post(
                f"{self.voicevox_url}/synthesis",
                params={"speaker": voice_id},
                json=audio_query
            ) as response:
                if response.status != 200:
                    error_text = await response.text()
                    raise aiohttp.ClientError(f"éŸ³å£°åˆæˆå¤±æ•—: HTTP {response.status} - {error_text}")
                
                audio_data = await response.read()
            
            # çµ±è¨ˆæ›´æ–°
            synthesis_time = time.time() - synthesis_start
            self.synthesis_times.append(synthesis_time)
            self.synthesis_count += 1
            
            # çµ±è¨ˆã‚µã‚¤ã‚ºåˆ¶é™
            if len(self.synthesis_times) > 100:
                self.synthesis_times = self.synthesis_times[-50:]
            
            logger.debug(f"ğŸµ VOICEVOXéŸ³å£°åˆæˆå®Œäº†: {len(audio_data)}bytes, {synthesis_time:.2f}s (ID:{voice_id})")
            return audio_data
            
        except Exception as e:
            synthesis_time = time.time() - synthesis_start
            self.synthesis_errors += 1
            self.error_history.append({
                "timestamp": datetime.now().isoformat(),
                "error": str(e),
                "voice_id": voice_id,
                "text_length": len(text),
                "synthesis_time": synthesis_time
            })
            
            # ã‚¨ãƒ©ãƒ¼å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™
            if len(self.error_history) > 20:
                self.error_history = self.error_history[-10:]
            
            logger.error(f"âŒ VOICEVOXéŸ³å£°åˆæˆã‚¨ãƒ©ãƒ¼ (ID:{voice_id}): {e}")
            return None
    
    async def test_synthesis(self, text: str = "VOICEVOXéŸ³å£°åˆæˆãƒ†ã‚¹ãƒˆã§ã™", 
                           voice_id: Optional[int] = None) -> bool:
        """éŸ³å£°åˆæˆãƒ†ã‚¹ãƒˆ"""
        if voice_id is None:
            voice_id = self.voice_settings.get("gyururu_voice_id", 46)
        
        logger.info(f"ğŸ§ª VOICEVOXåˆæˆãƒ†ã‚¹ãƒˆé–‹å§‹: '{text}' (ID:{voice_id})")
        
        audio_data = await self.synthesize_speech(text, voice_id)
        
        if audio_data:
            logger.info(f"âœ… VOICEVOXåˆæˆãƒ†ã‚¹ãƒˆæˆåŠŸ: {len(audio_data)}bytes")
            return True
        else:
            logger.error("âŒ VOICEVOXåˆæˆãƒ†ã‚¹ãƒˆå¤±æ•—")
            return False
    
    # === è©±è€…ç®¡ç†API ===
    
    def get_speakers(self) -> Dict[int, SpeakerInfo]:
        """è©±è€…ãƒªã‚¹ãƒˆå–å¾—"""
        return self.speakers.copy()
    
    def get_speaker_info(self, voice_id: int) -> Optional[SpeakerInfo]:
        """è©±è€…æƒ…å ±å–å¾—"""
        return self.speakers.get(voice_id)
    
    def get_speaker_name(self, voice_id: int) -> str:
        """è©±è€…åå–å¾—"""
        speaker_info = self.speakers.get(voice_id)
        if speaker_info:
            return speaker_info.name
        else:
            return f"Unknown Speaker ({voice_id})"
    
    def get_speakers_by_category(self, category: str) -> List[SpeakerInfo]:
        """ã‚«ãƒ†ã‚´ãƒªåˆ¥è©±è€…å–å¾—"""
        speaker_ids = self.speaker_categories.get(category, [])
        return [self.speakers[sid] for sid in speaker_ids if sid in self.speakers]
    
    def search_speakers(self, keyword: str) -> List[SpeakerInfo]:
        """è©±è€…æ¤œç´¢"""
        keyword_lower = keyword.lower()
        results = []
        
        for speaker_info in self.speakers.values():
            if (keyword_lower in speaker_info.name.lower() or 
                keyword_lower in speaker_info.speaker_name.lower() or
                keyword_lower in speaker_info.style_name.lower()):
                results.append(speaker_info)
        
        return results
    
    def get_categories(self) -> Dict[str, int]:
        """ã‚«ãƒ†ã‚´ãƒªçµ±è¨ˆå–å¾—"""
        return {category: len(speaker_ids) for category, speaker_ids in self.speaker_categories.items()}
    
    # === çŠ¶æ…‹ãƒ»çµ±è¨ˆå–å¾—API ===
    
    def get_connection_status(self) -> Dict[str, Any]:
        """æ¥ç¶šçŠ¶æ…‹å–å¾—"""
        return {
            "available": self.available,
            "version": self.version,
            "url": self.voicevox_url,
            "last_check": self.last_connection_check,
            "connection_retries": self.connection_retries,
            "speakers_loaded": self.speakers_loaded,
            "total_speakers": len(self.speakers)
        }
    
    def get_synthesis_stats(self) -> Dict[str, Any]:
        """åˆæˆçµ±è¨ˆå–å¾—"""
        avg_synthesis_time = 0
        if self.synthesis_times:
            avg_synthesis_time = sum(self.synthesis_times) / len(self.synthesis_times)
        
        success_rate = 0
        total_attempts = self.synthesis_count + self.synthesis_errors
        if total_attempts > 0:
            success_rate = (self.synthesis_count / total_attempts) * 100
        
        return {
            "total_synthesis": self.synthesis_count,
            "total_errors": self.synthesis_errors,
            "success_rate": round(success_rate, 2),
            "average_synthesis_time": round(avg_synthesis_time, 3),
            "recent_errors": self.error_history[-5:] if self.error_history else []
        }
    
    # === ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— ===
    
    async def cleanup(self) -> None:
        """ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            if self.session and not self.session.closed:
                await self.session.close()
                logger.debug("ğŸ§¹ VOICEVOX HTTPã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒ­ãƒ¼ã‚ºå®Œäº†")
            
            # çµ±è¨ˆãƒªã‚»ãƒƒãƒˆ
            self.speakers.clear()
            self.speaker_categories.clear()
            self.synthesis_times.clear()
            self.error_history.clear()
            
            self.available = False
            self.speakers_loaded = False
            
            logger.info("ğŸ§¹ VOICEVOX ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
            
        except Exception as e:
            logger.error(f"âŒ VOICEVOX ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")

# === ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ ===

__all__ = [
    "VOICEVOXClient"
]