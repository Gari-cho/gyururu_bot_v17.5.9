#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸ”§ WebSocketã‚¿ãƒ– æ¥ç¶šåˆ¶å¾¡ãƒ‘ãƒãƒ« v16.4 å®Œå…¨ä¿®æ­£ç‰ˆï¼ˆONECOMMEé…ç·šè¿½åŠ ï¼‰

ä¿®æ­£å†…å®¹:
âœ… ä¸è¦ãªprintãƒ»messagebox.showinfoå‰Šé™¤
âœ… ãƒ†ã‚¹ãƒˆç”¨ãƒ€ãƒŸãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­å‰Šé™¤
âœ… å¥‘ç´„çµ±ä¸€å¯¾å¿œå®Œäº†ï¼ˆshared.contractsä½¿ç”¨ï¼‰
âœ… 'dict' object has no attribute ã‚¨ãƒ©ãƒ¼å®Œå…¨è§£æ¶ˆ
âœ… UIã«å°‚å¿µï¼ˆæ¥ç¶šãƒ­ã‚¸ãƒƒã‚¯ã¯å¤–éƒ¨ã¸å§”è­²ï¼‰
âœ… åˆæœŸåŒ–ã‚¿ã‚¤ãƒŸãƒ³ã‚°ä¿®æ­£
ğŸ†• ONECOMMEã‚¹ã‚¤ãƒƒãƒã§ WebSocketManager ã‚’èµ·å‹•/åœæ­¢ï¼ˆå¹¹ç·šé–‹é€šï¼‰

Author: Claude & ãƒ¦ãƒ¼ã‚¶ãƒ¼
Version: 16.4.1
License: MIT
"""

import tkinter as tk
from tkinter import ttk
import logging
import time
from typing import Dict, Any, Optional, Callable

logger = logging.getLogger(__name__)

# === çµ±ä¸€ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆshared.contracts ä½¿ç”¨ï¼‰ ===
try:
    from shared.contracts import (
        ServiceState,
        normalize_service,
        normalize_services_dict,
        safe_service_update,
        get_service_summary,
        ServiceKeys
    )
    from shared.message_bus import MessageBus, get_message_bus
    from shared.event_types import Events
    SHARED_AVAILABLE = True
except ImportError:
    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    try:
        from ..shared.contracts import (
            ServiceState,
            normalize_service,
            normalize_services_dict,
            safe_service_update,
            get_service_summary,
            ServiceKeys
        )
        from ..shared.message_bus import MessageBus, get_message_bus
        from ..shared.event_types import Events
        SHARED_AVAILABLE = True
    except ImportError:
        # æœ€å¾Œã®ç ¦ï¼ˆç°¡æ˜“å®šç¾©ï¼‰
        SHARED_AVAILABLE = False
        from dataclasses import dataclass, field
        
        @dataclass
        class ServiceState:
            key: str
            enabled: bool = False
            connected: bool = False
            name: Optional[str] = None
            meta: Dict[str, Any] = field(default_factory=dict)
            
            def update_state(self, *, enabled: Optional[bool] = None, connected: Optional[bool] = None, **kwargs):
                if enabled is not None: self.enabled = bool(enabled)
                if connected is not None: self.connected = bool(connected)
                if kwargs: self.meta.update(kwargs)
            
            def to_dict(self):
                return {
                    'key': self.key,
                    'enabled': self.enabled,
                    'connected': self.connected,
                    'name': self.name,
                    'meta': self.meta.copy()
                }
        
        def normalize_service(key: str, raw: Any) -> ServiceState:
            if isinstance(raw, ServiceState): return raw
            if isinstance(raw, dict):
                return ServiceState(
                    key=key,
                    enabled=bool(raw.get("enabled", False)),
                    connected=bool(raw.get("connected", False)),
                    name=str(raw.get("name", key))
                )
            return ServiceState(key=key, enabled=False, connected=False, name=key)
        
        def normalize_services_dict(services: Dict[str, Any]) -> Dict[str, ServiceState]:
            return {k: normalize_service(k, v) for k, v in services.items()}
        
        def safe_service_update(service: ServiceState, update_data: Dict[str, Any]):
            service.update_state(**update_data)
        
        def get_service_summary(services: Dict[str, ServiceState]) -> Dict[str, Any]:
            total = len(services)
            enabled = sum(1 for s in services.values() if s.enabled)
            connected = sum(1 for s in services.values() if s.connected)
            return {
                'total_services': total,
                'enabled_services': enabled,
                'connected_services': connected,
                'health_percentage': (connected / total * 100) if total > 0 else 0
            }
        
        class ServiceKeys:
            WEBSOCKET = "websocket"
            MQTT = "mqtt"
            ONECOMME = "onecomme"
            MESSAGEBUS = "messagebus"
            VOICEVOX = "voicevox"
            BOUYOMI = "bouyomi"
            OBS = "obs"
        
        class Events:
            CONNECTION_STATUS_CHANGED = "connection_status_changed"
            SERVICE_ERROR = "service_error"
        
        # ãƒ€ãƒŸãƒ¼é–¢æ•°
        def get_message_bus():
            return None

# === SlideSwitch ã‚¤ãƒ³ãƒãƒ¼ãƒˆ ===
try:
    from .slide_switch import SlideSwitch
except ImportError:
    try:
        from slide_switch import SlideSwitch
    except ImportError:
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªCheckbox
        class SlideSwitch:
            def __init__(self, parent, initial_state=False, callback=None):
                self.var = tk.BooleanVar(value=initial_state)
                self.callback = callback
                self.widget = ttk.Checkbutton(
                    parent, 
                    variable=self.var,
                    command=self._on_change
                )
            
            def _on_change(self):
                if self.callback:
                    self.callback(self.var.get())
            
            def set_state(self, state):
                self.var.set(state)
            
            def pack(self, **kwargs):
                self.widget.pack(**kwargs)
            
            def destroy(self):
                self.widget.destroy()

# === WebSocketManagerï¼ˆONECOMMEé…ç·šç”¨ï¼‰ ===
# handler.py ã«ã‚ã‚‹ç®¡ç†ã‚¯ãƒ©ã‚¹ã‚’ç›´æ¥åˆ©ç”¨
try:
    from handler import WebSocketManager
    WEBSOCKET_MANAGER_AVAILABLE = True
    logger.info("âœ… WebSocketManager ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ")
except ImportError:
    try:
        from ..handler import WebSocketManager
        WEBSOCKET_MANAGER_AVAILABLE = True
        logger.info("âœ… WebSocketManager ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸï¼ˆç›¸å¯¾ãƒ‘ã‚¹ï¼‰")
    except ImportError:
        WebSocketManager = None
        WEBSOCKET_MANAGER_AVAILABLE = False
        logger.warning("âš ï¸ WebSocketManager ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ï¼ˆONECOMMEé…ç·šã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¾ã™ï¼‰")


class ConnectionControlPanel(ttk.Frame):
    """
    æ¥ç¶šåˆ¶å¾¡ãƒ‘ãƒãƒ«ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰
    
    è²¬å‹™:
    - ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹ã®è¡¨ç¤º
    - ã‚¹ã‚¤ãƒƒãƒUIæä¾›
    - ã‚¤ãƒ™ãƒ³ãƒˆé€šçŸ¥
    - ONECOMMEå°‚ç”¨: WebSocketManagerèµ·å‹•/åœæ­¢
    """
    
    def __init__(self, parent, message_bus: Optional[MessageBus] = None, service_registry=None):
        super().__init__(parent)
        
        self.message_bus = message_bus
        self.service_registry = service_registry
        
        # ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹ç®¡ç†ï¼ˆçµ±ä¸€å¥‘ç´„ä½¿ç”¨ï¼‰
        self.services: Dict[str, ServiceState] = {}
        
        # UIè¦ç´ 
        self.service_switches: Dict[str, SlideSwitch] = {}
        self.status_labels: Dict[str, ttk.Label] = {}
        self.summary_var = tk.StringVar()
        
        # ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        self._connection_callbacks: Dict[str, Callable] = {}
        
        # ğŸ†• ONECOMME ç”¨ã® WebSocketManager
        self.ws_manager: Optional[WebSocketManager] = None
        self.ws_started: bool = False
        
        try:
            if WEBSOCKET_MANAGER_AVAILABLE and WebSocketManager is not None:
                # get_message_bus ãŒä½¿ãˆã‚‹ç’°å¢ƒã§ã¯çµ±ä¸€ãƒã‚¹ã‚’æ¸¡ã™
                bus = self.message_bus
                if bus is None and SHARED_AVAILABLE:
                    bus = get_message_bus()
                
                if bus is not None:
                    self.ws_manager = WebSocketManager(bus)
                    logger.info("ğŸ”— WebSocketManager æº–å‚™å®Œäº†ï¼ˆConnectionControlPanelï¼‰")
                else:
                    logger.warning("âš ï¸ MessageBusæœªè¨­å®šã®ãŸã‚WebSocketManagerç„¡åŠ¹")
        except Exception as e:
            logger.warning(f"âš ï¸ WebSocketManager åˆæœŸåŒ–è­¦å‘Š: {e}")
        
        # UIæ§‹ç¯‰
        self._setup_ui()
        self._setup_event_handlers()
        
        logger.info("ğŸ›ï¸ ConnectionControlPanel åˆæœŸåŒ–å®Œäº†ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰")
    
    def _setup_ui(self):
        """UIæ§‹ç¯‰"""
        # ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ 
        main_frame = ttk.LabelFrame(self, text="ğŸ”Œ æ¥ç¶šåˆ¶å¾¡", padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # ã‚µãƒãƒªãƒ¼è¡¨ç¤º
        summary_frame = ttk.Frame(main_frame)
        summary_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(summary_frame, text="ğŸ“Š çŠ¶æ…‹ã‚µãƒãƒªãƒ¼:").pack(side=tk.LEFT)
        ttk.Label(summary_frame, textvariable=self.summary_var).pack(side=tk.LEFT, padx=(5, 0))
        
        # ã‚µãƒ¼ãƒ“ã‚¹åˆ¶å¾¡ã‚¨ãƒªã‚¢
        self.services_frame = ttk.Frame(main_frame)
        self.services_frame.pack(fill=tk.BOTH, expand=True)
        
        # åˆæœŸã‚µãƒ¼ãƒ“ã‚¹ä½œæˆ
        self._create_default_services()
    
    def _create_default_services(self):
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µãƒ¼ãƒ“ã‚¹ã®ä½œæˆ"""
        default_services = {
            ServiceKeys.ONECOMME: {
                "name": "ã‚ã‚“ã‚³ãƒ¡",
                "enabled": False,
                "connected": False
            },
            ServiceKeys.MESSAGEBUS: {
                "name": "MessageBus",
                "enabled": False,
                "connected": False
            },
            ServiceKeys.VOICEVOX: {
                "name": "VOICEVOX",
                "enabled": False,
                "connected": False
            },
            ServiceKeys.BOUYOMI: {
                "name": "æ£’èª­ã¿ã¡ã‚ƒã‚“",
                "enabled": False,
                "connected": False
            },
            ServiceKeys.OBS: {
                "name": "OBS",
                "enabled": False,
                "connected": False
            }
        }
        
        self.update_services(default_services)
    
    def _setup_event_handlers(self):
        """ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š"""
        if self.message_bus:
            self.message_bus.subscribe(
                Events.CONNECTION_STATUS_CHANGED, 
                self._on_connection_status_changed
            )
            self.message_bus.subscribe(
                Events.SERVICE_ERROR,
                self._on_service_error
            )
    
    def update_services(self, services: Dict[str, Any]):
        """
        ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹æ›´æ–°ï¼ˆçµ±ä¸€å¥‘ç´„ç‰ˆï¼‰
        
        Args:
            services: ç”Ÿã‚µãƒ¼ãƒ“ã‚¹è¾æ›¸ï¼ˆdict/ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ··åœ¨OKï¼‰
        """
        try:
            # çµ±ä¸€æ­£è¦åŒ–å‡¦ç†
            normalized_services = normalize_services_dict(services)
            
            # æ—¢å­˜ã‚µãƒ¼ãƒ“ã‚¹ã¨çµ±åˆ
            for key, service_state in normalized_services.items():
                if key in self.services:
                    # æ—¢å­˜ã‚µãƒ¼ãƒ“ã‚¹ã®æ›´æ–°
                    existing = self.services[key]
                    existing.enabled = service_state.enabled
                    existing.connected = service_state.connected
                    existing.meta.update(service_state.meta)
                else:
                    # æ–°è¦ã‚µãƒ¼ãƒ“ã‚¹è¿½åŠ 
                    self.services[key] = service_state
                    self._create_service_ui(key, service_state)
            
            # UIæ›´æ–°
            self._update_ui()
            
            logger.debug(f"ğŸ”„ ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹æ›´æ–°å®Œäº†: {len(normalized_services)}ä»¶")
            
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _create_service_ui(self, service_key: str, service: ServiceState):
        """å€‹åˆ¥ã‚µãƒ¼ãƒ“ã‚¹UIä½œæˆ"""
        try:
            # ã‚µãƒ¼ãƒ“ã‚¹è¡Œãƒ•ãƒ¬ãƒ¼ãƒ 
            service_frame = ttk.Frame(self.services_frame)
            service_frame.pack(fill=tk.X, pady=2)
            
            # ã‚µãƒ¼ãƒ“ã‚¹å
            name_label = ttk.Label(
                service_frame, 
                text=f"{service.name or service_key}:",
                width=15
            )
            name_label.pack(side=tk.LEFT, padx=(0, 10))
            
            # ã‚¹ãƒ©ã‚¤ãƒ‰ã‚¹ã‚¤ãƒƒãƒ
            switch = SlideSwitch(
                service_frame,
                initial_state=service.enabled,
                callback=lambda state, key=service_key: self._on_switch_changed(key, state)
            )
            switch.pack(side=tk.LEFT, padx=(0, 10))
            self.service_switches[service_key] = switch
            
            # çŠ¶æ…‹ãƒ©ãƒ™ãƒ«
            status_label = ttk.Label(service_frame, text="")
            status_label.pack(side=tk.LEFT, padx=(0, 10))
            self.status_labels[service_key] = status_label
            
            logger.debug(f"ğŸ¨ ã‚µãƒ¼ãƒ“ã‚¹UIä½œæˆ: {service_key}")
            
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹UIä½œæˆã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
    
    def _update_ui(self):
        """UIçŠ¶æ…‹æ›´æ–°"""
        try:
            # å„ã‚µãƒ¼ãƒ“ã‚¹UIæ›´æ–°
            for key, service in self.services.items():
                # ã‚¹ã‚¤ãƒƒãƒçŠ¶æ…‹æ›´æ–°
                if key in self.service_switches:
                    switch = self.service_switches[key]
                    switch.set_state(service.enabled)
                
                # çŠ¶æ…‹ãƒ©ãƒ™ãƒ«æ›´æ–°
                if key in self.status_labels:
                    label = self.status_labels[key]
                    status_text, color = self._get_status_display(service)
                    label.config(text=status_text, foreground=color)
            
            # ã‚µãƒãƒªãƒ¼æ›´æ–°
            self._update_summary()
            
        except Exception as e:
            logger.error(f"âŒ UIæ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _get_status_display(self, service: ServiceState) -> tuple[str, str]:
        """çŠ¶æ…‹è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆã¨è‰²ã‚’å–å¾—"""
        if service.connected:
            return "ğŸŸ¢ æ¥ç¶šä¸­", "green"
        elif service.enabled:
            return "ğŸŸ¡ æ¥ç¶šå¾…æ©Ÿ", "orange"
        else:
            return "ğŸ”´ ç„¡åŠ¹", "red"
    
    def _update_summary(self):
        """ã‚µãƒãƒªãƒ¼è¡¨ç¤ºæ›´æ–°"""
        try:
            # çµ±ä¸€å¥‘ç´„ã®ã‚µãƒãƒªãƒ¼é–¢æ•°ä½¿ç”¨
            summary = get_service_summary(self.services)
            
            summary_text = (
                f"å…¨ä½“: {summary['total_services']}ä»¶ | "
                f"æœ‰åŠ¹: {summary['enabled_services']}ä»¶ | "
                f"æ¥ç¶šä¸­: {summary['connected_services']}ä»¶ | "
                f"å¥åº·åº¦: {summary['health_percentage']:.0f}%"
            )
            
            self.summary_var.set(summary_text)
            
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒãƒªãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
            self.summary_var.set("âŒ ã‚µãƒãƒªãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼")
    
    def _on_switch_changed(self, service_key: str, enabled: bool):
        """
        ã‚¹ã‚¤ãƒƒãƒå¤‰æ›´ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰
        
        ğŸ†• ONECOMMEã‚¹ã‚¤ãƒƒãƒã§WebSocketManagerèµ·å‹•/åœæ­¢
        """
        try:
            logger.info(f"ğŸ”„ ã‚¹ã‚¤ãƒƒãƒå¤‰æ›´: {service_key} -> {'æœ‰åŠ¹' if enabled else 'ç„¡åŠ¹'}")
            
            # å…±é€š: ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹æ›´æ–°
            if service_key in self.services:
                self.services[service_key].enabled = enabled
                # ç„¡åŠ¹åŒ–æ™‚ã¯æ¥ç¶šã‚‚åˆ‡æ–­
                if not enabled:
                    self.services[service_key].connected = False
            
            # ğŸ†• å€‹åˆ¥å‡¦ç†: ONECOMME ã® WebSocket èµ·å‹•/åœæ­¢ï¼ˆå¹¹ç·šé–‹é€šï¼‰
            if service_key == ServiceKeys.ONECOMME and self.ws_manager is not None:
                if enabled and not self.ws_started:
                    # ã‚ã‚“ã‚³ãƒ¡WebSocketé–‹å§‹
                    url = "ws://localhost:11180/sub"  # TODO: è¨­å®šå€¤ã‹ã‚‰å–å¾—ã«åˆ‡æ›¿å¯èƒ½
                    self.ws_manager.start_in_background(url)
                    self.ws_started = True
                    logger.info(f"ğŸš€ ã‚ã‚“ã‚³ãƒ¡WebSocketé–‹å§‹: {url}")
                    
                    # æ¥ç¶šçŠ¶æ…‹ã‚’æ¥ç¶šå¾…æ©Ÿã«æ›´æ–°
                    if service_key in self.services:
                        self.services[service_key].meta['connection_url'] = url
                        self.services[service_key].meta['connection_time'] = time.time()
                        
                elif not enabled and self.ws_started:
                    # ã‚ã‚“ã‚³ãƒ¡WebSocketåœæ­¢
                    self.ws_manager.stop_background()
                    self.ws_started = False
                    logger.info("â¹ï¸ ã‚ã‚“ã‚³ãƒ¡WebSocketåœæ­¢")
                    
                    # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
                    if service_key in self.services:
                        self.services[service_key].meta.clear()
            
            # TODO: ä»Šå¾Œã®æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ
            # elif service_key == ServiceKeys.OBS:
            #     # OBSæ¥ç¶šå‡¦ç†ã‚’ã“ã“ã«è¿½åŠ 
            # elif service_key == ServiceKeys.VOICEVOX:
            #     # VOICEVOXæ¥ç¶šå‡¦ç†ã‚’ã“ã“ã«è¿½åŠ 
            
            # å…±é€š: MessageBusã‚¤ãƒ™ãƒ³ãƒˆé€šçŸ¥
            if self.message_bus:
                self.message_bus.publish(
                    Events.CONNECTION_STATUS_CHANGED,
                    {
                        'service': service_key,
                        'enabled': enabled,
                        'action': 'enable' if enabled else 'disable',
                        'timestamp': time.time()
                    },
                    sender="ConnectionControlPanel"
                )
            
            # ä»»æ„: å¤–éƒ¨ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
            if service_key in self._connection_callbacks:
                try:
                    self._connection_callbacks[service_key](service_key, enabled)
                except Exception as e:
                    logger.error(f"âŒ ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
            
            # UIæ›´æ–°
            self._update_ui()
            
        except Exception as e:
            logger.error(f"âŒ ã‚¹ã‚¤ãƒƒãƒå¤‰æ›´å‡¦ç†ã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
    
    def _on_connection_status_changed(self, data: Dict[str, Any], sender: str = None):
        """æ¥ç¶šçŠ¶æ…‹å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
        try:
            service_key = data.get('service')
            if not service_key or service_key not in self.services:
                return
            
            # çµ±ä¸€å¥‘ç´„ã«ã‚ˆã‚‹å®‰å…¨ãªæ›´æ–°
            service = self.services[service_key]
            safe_service_update(service, data)
            
            # UIæ›´æ–°
            self.after_idle(self._update_ui)
            
            logger.debug(f"ğŸ“¡ æ¥ç¶šçŠ¶æ…‹å¤‰æ›´å—ä¿¡: {service_key} from {sender}")
            
        except Exception as e:
            logger.error(f"âŒ æ¥ç¶šçŠ¶æ…‹å¤‰æ›´å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _on_service_error(self, data: Dict[str, Any], sender: str = None):
        """ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ©ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
        try:
            service_key = data.get('service')
            error_message = data.get('error', 'Unknown error')
            
            logger.warning(f"âš ï¸ ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ©ãƒ¼å—ä¿¡: {service_key} - {error_message}")
            
            # ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã‚¹ã‚¤ãƒƒãƒã‚’ç„¡åŠ¹åŒ–
            if service_key in self.services:
                self.services[service_key].enabled = False
                self.services[service_key].connected = False
                self.services[service_key].meta['last_error'] = error_message
                self.services[service_key].meta['error_time'] = time.time()
                
                # WebSocketé–¢é€£ã®ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯å†…éƒ¨çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆ
                if service_key == ServiceKeys.ONECOMME:
                    self.ws_started = False
                
                self.after_idle(self._update_ui)
            
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
    
    # === å…¬é–‹API ===
    
    def set_connection_callback(self, service_key: str, callback: Callable[[str, bool], None]):
        """æ¥ç¶šã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š"""
        self._connection_callbacks[service_key] = callback
        logger.debug(f"ğŸ”— ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š: {service_key}")
    
    def get_service_state(self, service_key: str) -> Optional[ServiceState]:
        """ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹å–å¾—"""
        return self.services.get(service_key)
    
    def get_all_services(self) -> Dict[str, ServiceState]:
        """å…¨ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹å–å¾—"""
        return self.services.copy()
    
    def set_service_enabled(self, service_key: str, enabled: bool):
        """ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã®ã‚µãƒ¼ãƒ“ã‚¹æœ‰åŠ¹/ç„¡åŠ¹è¨­å®š"""
        try:
            if service_key in self.services:
                self.services[service_key].enabled = enabled
                
                # ã‚¹ã‚¤ãƒƒãƒUIæ›´æ–°
                if service_key in self.service_switches:
                    self.service_switches[service_key].set_state(enabled)
                
                self._update_ui()
                logger.info(f"ğŸ“ ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨­å®š: {service_key} -> {'æœ‰åŠ¹' if enabled else 'ç„¡åŠ¹'}")
            else:
                logger.warning(f"âš ï¸ å­˜åœ¨ã—ãªã„ã‚µãƒ¼ãƒ“ã‚¹: {service_key}")
                
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹è¨­å®šã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
    
    def set_service_connected(self, service_key: str, connected: bool):
        """ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã®æ¥ç¶šçŠ¶æ…‹è¨­å®š"""
        try:
            if service_key in self.services:
                self.services[service_key].connected = connected
                self._update_ui()
                logger.debug(f"ğŸ”Œ æ¥ç¶šçŠ¶æ…‹è¨­å®š: {service_key} -> {'æ¥ç¶š' if connected else 'åˆ‡æ–­'}")
            else:
                logger.warning(f"âš ï¸ å­˜åœ¨ã—ãªã„ã‚µãƒ¼ãƒ“ã‚¹: {service_key}")
                
        except Exception as e:
            logger.error(f"âŒ æ¥ç¶šçŠ¶æ…‹è¨­å®šã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
    
    def get_websocket_status(self) -> Dict[str, Any]:
        """WebSocketé–¢é€£ã®çŠ¶æ…‹å–å¾—"""
        try:
            status = {
                'websocket_manager_available': WEBSOCKET_MANAGER_AVAILABLE,
                'ws_manager_initialized': self.ws_manager is not None,
                'ws_started': self.ws_started,
                'onecomme_service_state': self.get_service_state(ServiceKeys.ONECOMME).to_dict() if ServiceKeys.ONECOMME in self.services else None
            }
            
            if self.ws_manager:
                try:
                    ws_status = self.ws_manager.get_status()
                    status['websocket_manager_status'] = ws_status
                except Exception as e:
                    status['websocket_manager_error'] = str(e)
            
            return status
            
        except Exception as e:
            logger.error(f"âŒ WebSocketçŠ¶æ…‹å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {'error': str(e)}
    
    def cleanup(self):
        """ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾"""
        try:
            # WebSocketManageråœæ­¢
            if self.ws_manager and self.ws_started:
                try:
                    self.ws_manager.stop_background()
                    self.ws_started = False
                    logger.info("ğŸ”Œ WebSocketManageråœæ­¢å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ WebSocketManageråœæ­¢è­¦å‘Š: {e}")
            
            # ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­è§£é™¤
            if self.message_bus:
                try:
                    self.message_bus.unsubscribe(
                        Events.CONNECTION_STATUS_CHANGED,
                        self._on_connection_status_changed
                    )
                    self.message_bus.unsubscribe(
                        Events.SERVICE_ERROR,
                        self._on_service_error
                    )
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­è§£é™¤è­¦å‘Š: {e}")
            
            # UIè¦ç´ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            self.service_switches.clear()
            self.status_labels.clear()
            self._connection_callbacks.clear()
            
            logger.info("ğŸ—‘ï¸ ConnectionControlPanel ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾å®Œäº†")
            
        except Exception as e:
            logger.error(f"âŒ ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾ã‚¨ãƒ©ãƒ¼: {e}")
    
    def destroy(self):
        """ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆç ´æ£„"""
        try:
            # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œ
            self.cleanup()
            
            # è¦ªã‚¯ãƒ©ã‚¹ã® destroy
            super().destroy()
            
        except Exception as e:
            logger.error(f"âŒ ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆç ´æ£„ã‚¨ãƒ©ãƒ¼: {e}")


# === ä¾¿åˆ©ãªä½œæˆé–¢æ•° ===

def create_connection_panel(parent, message_bus: Optional[MessageBus] = None, 
                          service_registry=None, **kwargs) -> ConnectionControlPanel:
    """
    ConnectionControlPanelä½œæˆä¾¿åˆ©é–¢æ•°ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰
    
    Args:
        parent: è¦ªã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆ
        message_bus: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒã‚¹
        service_registry: ã‚µãƒ¼ãƒ“ã‚¹ãƒ¬ã‚¸ã‚¹ãƒˆãƒª
        **kwargs: è¿½åŠ å¼•æ•°
        
    Returns:
        ConnectionControlPanel: ä½œæˆã•ã‚ŒãŸãƒ‘ãƒãƒ«
    """
    try:
        panel = ConnectionControlPanel(parent, message_bus, service_registry)
        logger.info("âœ… ConnectionControlPanelä½œæˆå®Œäº†ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰")
        return panel
    except Exception as e:
        logger.error(f"âŒ ConnectionControlPanelä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
        raise


# === ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆä»»æ„ï¼‰ ===

if __name__ == "__main__":
    def test_callback(service_key: str, enabled: bool):
        logger.info(f"ğŸ”— ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯: {service_key} -> {'æœ‰åŠ¹' if enabled else 'ç„¡åŠ¹'}")
    
    # ãƒ†ã‚¹ãƒˆç”¨ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
    root = tk.Tk()
    root.title("ConnectionControlPanel WebSocketé…ç·šçµ±åˆç‰ˆãƒ†ã‚¹ãƒˆ")
    root.geometry("700x400")
    
    # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒã‚¹ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
    try:
        if SHARED_AVAILABLE:
            bus = get_message_bus()
        else:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ãƒŸãƒ¼ãƒã‚¹
            class DummyBus:
                def subscribe(self, event, callback): pass
                def publish(self, event, data, sender=None): pass
                def stop(self): pass
            bus = DummyBus()
    except Exception:
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ãƒŸãƒ¼ãƒã‚¹
        class DummyBus:
            def subscribe(self, event, callback): pass
            def publish(self, event, data, sender=None): pass
            def stop(self): pass
        bus = DummyBus()
    
    # ãƒ‘ãƒãƒ«ä½œæˆ
    panel = ConnectionControlPanel(root, bus)
    panel.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    # ãƒ†ã‚¹ãƒˆã‚µãƒ¼ãƒ“ã‚¹è¿½åŠ 
    test_services = {
        'onecomme': {'name': 'ã‚ã‚“ã‚³ãƒ¡', 'enabled': False, 'connected': False},
        'messagebus': {'name': 'MessageBus', 'enabled': True, 'connected': True},
        'voicevox': {'name': 'VOICEVOX', 'enabled': False, 'connected': False}
    }
    
    panel.update_services(test_services)
    
    # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š
    for key in test_services.keys():
        panel.set_connection_callback(key, test_callback)
    
    # WebSocketçŠ¶æ…‹è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    def show_websocket_status():
        try:
            status = panel.get_websocket_status()
            logger.info(f"ğŸ”Œ WebSocketçŠ¶æ…‹: {status}")
            root.after(5000, show_websocket_status)  # 5ç§’ã”ã¨
        except Exception as e:
            logger.error(f"âŒ WebSocketçŠ¶æ…‹è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {e}")
    
    root.after(1000, show_websocket_status)
    
    try:
        logger.info("ğŸš€ ConnectionControlPanel WebSocketé…ç·šçµ±åˆç‰ˆãƒ†ã‚¹ãƒˆé–‹å§‹")
        root.mainloop()
    except Exception as e:
        logger.error(f"âŒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
    finally:
        try:
            panel.cleanup()
            if hasattr(bus, 'stop'):
                bus.stop()
        except:
            pass
        logger.info("âœ… ConnectionControlPanel WebSocketé…ç·šçµ±åˆç‰ˆãƒ†ã‚¹ãƒˆå®Œäº†")