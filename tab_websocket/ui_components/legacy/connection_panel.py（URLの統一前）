#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸ”§ WebSocketã‚¿ãƒ– æ¥ç¶šåˆ¶å¾¡ãƒ‘ãƒãƒ« v17.0 GUIå¾©æ—§ä¿®æ­£ç‰ˆ

ä¿®æ­£å†…å®¹:
âœ… æ§‹æ–‡ã‚¨ãƒ©ãƒ¼å®Œå…¨è§£æ¶ˆ
âœ… ä¸è¦ãªprintãƒ»messagebox.showinfoå‰Šé™¤
âœ… ãƒ†ã‚¹ãƒˆç”¨ãƒ€ãƒŸãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­å‰Šé™¤
âœ… å¥‘ç´„çµ±ä¸€å¯¾å¿œå®Œäº†ï¼ˆshared.contractsä½¿ç”¨ï¼‰
âœ… 'dict' object has no attribute ã‚¨ãƒ©ãƒ¼å®Œå…¨è§£æ¶ˆ
âœ… UIã«å°‚å¿µï¼ˆæ¥ç¶šãƒ­ã‚¸ãƒƒã‚¯ã¯å¤–éƒ¨ã¸å§”è­²ï¼‰
âœ… åˆæœŸåŒ–ã‚¿ã‚¤ãƒŸãƒ³ã‚°ä¿®æ­£
âœ… ONECOMMEã‚¹ã‚¤ãƒƒãƒã§ WebSocketManager ã‚’èµ·å‹•/åœæ­¢ï¼ˆå¹¹ç·šé–‹é€šï¼‰

Author: Claude & ãƒ¦ãƒ¼ã‚¶ãƒ¼
Version: 17.0.1
License: MIT
"""

import tkinter as tk
from tkinter import ttk
import logging
import time
from typing import Dict, Any, Optional, Callable

logger = logging.getLogger(__name__)

# === çµ±ä¸€ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆshared.contracts ä½¿ç”¨ï¼‰ ===
try:
    from shared.contracts import (
        ServiceState,
        normalize_service,
        normalize_services_dict,
        safe_service_update,
        get_service_summary,
        ServiceKeys
    )
    from shared.message_bus import MessageBus, get_message_bus
    from shared.event_types import Events
    SHARED_AVAILABLE = True
except ImportError:
    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    try:
        from ..shared.contracts import (
            ServiceState,
            normalize_service,
            normalize_services_dict,
            safe_service_update,
            get_service_summary,
            ServiceKeys
        )
        from ..shared.message_bus import MessageBus, get_message_bus
        from ..shared.event_types import Events
        SHARED_AVAILABLE = True
    except ImportError:
        # æœ€å¾Œã®ç ¦ï¼ˆç°¡æ˜“å®šç¾©ï¼‰
        SHARED_AVAILABLE = False
        from dataclasses import dataclass, field
        
        @dataclass
        class ServiceState:
            key: str
            enabled: bool = False
            connected: bool = False
            name: Optional[str] = None
            meta: Dict[str, Any] = field(default_factory=dict)
            
            def update_state(self, *, enabled: Optional[bool] = None, connected: Optional[bool] = None, **kwargs):
                if enabled is not None: self.enabled = bool(enabled)
                if connected is not None: self.connected = bool(connected)
                if kwargs: self.meta.update(kwargs)
            
            def to_dict(self):
                return {
                    'key': self.key,
                    'enabled': self.enabled,
                    'connected': self.connected,
                    'name': self.name,
                    'meta': self.meta.copy()
                }
        
        def normalize_service(key: str, raw: Any) -> ServiceState:
            if isinstance(raw, ServiceState): return raw
            if isinstance(raw, dict):
                return ServiceState(
                    key=key,
                    enabled=raw.get('enabled', False),
                    connected=raw.get('connected', False),
                    name=raw.get('name', key),
                    meta=raw.get('meta', {})
                )
            return ServiceState(key=key, name=key)
        
        def normalize_services_dict(raw_services: Dict) -> Dict[str, ServiceState]:
            return {k: normalize_service(k, v) for k, v in raw_services.items()}
        
        def safe_service_update(service: ServiceState, **updates) -> bool:
            try:
                service.update_state(**updates)
                return True
            except: return False
        
        def get_service_summary(services: Dict[str, ServiceState]) -> str:
            enabled = sum(1 for s in services.values() if s.enabled)
            connected = sum(1 for s in services.values() if s.connected)
            return f"æœ‰åŠ¹: {enabled}/{len(services)}, æ¥ç¶š: {connected}/{len(services)}"
        
        class ServiceKeys:
            ONECOMME = "onecomme"
            MESSAGEBUS = "messagebus"
            VOICEVOX = "voicevox"
        
        class Events:
            CONNECTION_STATUS_CHANGED = "connection_status_changed"
            SERVICE_ERROR = "service_error"
        
        MessageBus = object

# === æ–°ç‰ˆSlideSwitchï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰ ===
try:
    from .slide_switch import SlideSwitch
    SLIDE_SWITCH_AVAILABLE = True
    logger.info("âœ… æ–°ç‰ˆSlideSwitchåˆ©ç”¨å¯èƒ½")
except ImportError:
    SLIDE_SWITCH_AVAILABLE = False
    logger.info("ğŸ“± æ–°ç‰ˆSlideSwitchæœªä½¿ç”¨ - æ¨™æº–Checkbuttonä½¿ç”¨")
    
    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ¨™æº–Checkbutton
    class SlideSwitch:
        def __init__(self, parent, text="", callback=None, **kwargs):
            self.widget = ttk.Checkbutton(parent, text=text, **kwargs)
            self.callback = callback
            self.var = tk.BooleanVar()
            self.widget.config(variable=self.var)
            if callback:
                self.widget.config(command=self._on_toggle)
        
        def _on_toggle(self):
            if self.callback:
                self.callback(self.var.get())
        
        def pack(self, **kwargs):
            self.widget.pack(**kwargs)
        
        def grid(self, **kwargs):
            self.widget.grid(**kwargs)
        
        def set_state(self, enabled: bool):
            self.var.set(enabled)
        
        def get_state(self) -> bool:
            return self.var.get()
        
        def destroy(self):
            self.widget.destroy()

# === WebSocketManagerï¼ˆONECOMMEé…ç·šç”¨ï¼‰ ===
# handler.py ã«ã‚ã‚‹ç®¡ç†ã‚¯ãƒ©ã‚¹ã‚’ç›´æ¥åˆ©ç”¨
try:
    from .handler import WebSocketManager
    WEBSOCKET_MANAGER_AVAILABLE = True
    logger.info("âœ… WebSocketManager ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ")
except ImportError:
    try:
        from ..handler import WebSocketManager
        WEBSOCKET_MANAGER_AVAILABLE = True
        logger.info("âœ… WebSocketManager ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸï¼ˆç›¸å¯¾ãƒ‘ã‚¹ï¼‰")
    except ImportError:
        WebSocketManager = None
        WEBSOCKET_MANAGER_AVAILABLE = False
        logger.warning("âš ï¸ WebSocketManager ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ï¼ˆONECOMMEé…ç·šã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¾ã™ï¼‰")


class ConnectionControlPanel(ttk.Frame):
    """
    æ¥ç¶šåˆ¶å¾¡ãƒ‘ãƒãƒ«ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰
    
    è²¬å‹™:
    - ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹ã®è¡¨ç¤º
    - ã‚¹ã‚¤ãƒƒãƒUIæä¾›
    - ã‚¤ãƒ™ãƒ³ãƒˆé€šçŸ¥
    - ONECOMMEå°‚ç”¨: WebSocketManagerèµ·å‹•/åœæ­¢
    """
    
    def __init__(self, parent, message_bus: Optional[MessageBus] = None, service_registry=None):
        super().__init__(parent)
        
        self.message_bus = message_bus
        self.service_registry = service_registry
        
        # ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹ç®¡ç†ï¼ˆçµ±ä¸€å¥‘ç´„ä½¿ç”¨ï¼‰
        self.services: Dict[str, ServiceState] = {}
        
        # UIè¦ç´ 
        self.service_switches: Dict[str, SlideSwitch] = {}
        self.status_labels: Dict[str, ttk.Label] = {}
        self.summary_var = tk.StringVar()
        
        # ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        self._connection_callbacks: Dict[str, Callable] = {}
        
        # ğŸ†• ONECOMME ç”¨ã® WebSocketManager
        self.ws_manager: Optional[WebSocketManager] = None
        self.ws_started: bool = False
        
        try:
            if WEBSOCKET_MANAGER_AVAILABLE and WebSocketManager is not None:
                # get_message_bus ãŒä½¿ãˆã‚‹ç’°å¢ƒã§ã¯çµ±ä¸€ãƒã‚¹ã‚’æ¸¡ã™
                bus = self.message_bus
                if bus is None and SHARED_AVAILABLE:
                    try:
                        bus = get_message_bus()
                    except:
                        pass
                
                if bus is not None:
                    self.ws_manager = WebSocketManager(bus)
                    logger.info("ğŸ”— WebSocketManager æº–å‚™å®Œäº†ï¼ˆConnectionControlPanelï¼‰")
                else:
                    logger.warning("âš ï¸ MessageBusæœªè¨­å®šã®ãŸã‚WebSocketManagerç„¡åŠ¹")
        except Exception as e:
            logger.warning(f"âš ï¸ WebSocketManager åˆæœŸåŒ–è­¦å‘Š: {e}")
        
        # UIæ§‹ç¯‰
        self._setup_ui()
        self._setup_event_handlers()
        
        logger.info("ğŸ›ï¸ ConnectionControlPanel åˆæœŸåŒ–å®Œäº†ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰")
    
    def _setup_ui(self):
        """UIæ§‹ç¯‰"""
        # ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ 
        main_frame = ttk.LabelFrame(self, text="ğŸ”Œ æ¥ç¶šåˆ¶å¾¡", padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # ã‚µãƒãƒªãƒ¼è¡¨ç¤ºã‚¨ãƒªã‚¢
        summary_frame = ttk.Frame(main_frame)
        summary_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(summary_frame, text="ğŸ“Š æ¥ç¶šçŠ¶æ³:").pack(side=tk.LEFT)
        summary_label = ttk.Label(summary_frame, textvariable=self.summary_var)
        summary_label.pack(side=tk.LEFT, padx=(5, 0))
        
        # ã‚µãƒ¼ãƒ“ã‚¹åˆ¶å¾¡ã‚¨ãƒªã‚¢ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œï¼‰
        canvas = tk.Canvas(main_frame, height=200)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        self.scrollable_frame = scrollable_frame
        
        # åˆæœŸã‚µãƒ¼ãƒ“ã‚¹è¿½åŠ 
        self._add_default_services()
        
        # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        self._update_ui()
    
    def _add_default_services(self):
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µãƒ¼ãƒ“ã‚¹è¿½åŠ """
        default_services = {
            ServiceKeys.ONECOMME: {
                'name': 'ã‚ã‚“ã‚³ãƒ¡',
                'enabled': False,
                'connected': False,
                'meta': {'description': 'ã‚ã‚“ã‚³ãƒ¡ã‹ã‚‰ã®ã‚³ãƒ¡ãƒ³ãƒˆå—ä¿¡'}
            },
            ServiceKeys.MESSAGEBUS: {
                'name': 'MessageBus',
                'enabled': self.message_bus is not None,
                'connected': self.message_bus is not None,
                'meta': {'description': 'ã‚¢ãƒ—ãƒªå†…ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…ä¿¡'}
            },
            ServiceKeys.VOICEVOX: {
                'name': 'VOICEVOX',
                'enabled': False,
                'connected': False,
                'meta': {'description': 'éŸ³å£°èª­ã¿ä¸Šã’ã‚µãƒ¼ãƒ“ã‚¹'}
            }
        }
        
        self.update_services(default_services)
    
    def _setup_event_handlers(self):
        """ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š"""
        if self.message_bus and SHARED_AVAILABLE:
            try:
                # æ¥ç¶šçŠ¶æ…‹å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
                self.message_bus.subscribe(
                    Events.CONNECTION_STATUS_CHANGED,
                    self._on_connection_status_changed
                )
                
                # ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ©ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
                self.message_bus.subscribe(
                    Events.SERVICE_ERROR,
                    self._on_service_error
                )
                
                logger.debug("ğŸ”” ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®šå®Œäº†")
                
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®šè­¦å‘Š: {e}")
    
    def update_services(self, services_data: Dict[str, Any]):
        """ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±æ›´æ–°"""
        try:
            # ãƒ‡ãƒ¼ã‚¿æ­£è¦åŒ–
            if SHARED_AVAILABLE:
                normalized = normalize_services_dict(services_data)
            else:
                normalized = {k: normalize_service(k, v) for k, v in services_data.items()}
            
            # æ—¢å­˜ã‚µãƒ¼ãƒ“ã‚¹æ›´æ–°ãƒ»æ–°è¦è¿½åŠ 
            for key, service_state in normalized.items():
                if key in self.services:
                    # æ—¢å­˜æ›´æ–°
                    if SHARED_AVAILABLE:
                        safe_service_update(
                            self.services[key],
                            enabled=service_state.enabled,
                            connected=service_state.connected,
                            **service_state.meta
                        )
                    else:
                        self.services[key].update_state(
                            enabled=service_state.enabled,
                            connected=service_state.connected,
                            **service_state.meta
                        )
                else:
                    # æ–°è¦è¿½åŠ 
                    self.services[key] = service_state
                    self._create_service_ui(key, service_state)
            
            # UIæ›´æ–°
            self._update_ui()
            
            logger.debug(f"ğŸ“ ã‚µãƒ¼ãƒ“ã‚¹æ›´æ–°: {list(normalized.keys())}")
            
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _create_service_ui(self, service_key: str, service_state: ServiceState):
        """ã‚µãƒ¼ãƒ“ã‚¹ç”¨UIä½œæˆ"""
        try:
            # ã‚µãƒ¼ãƒ“ã‚¹è¡Œãƒ•ãƒ¬ãƒ¼ãƒ 
            service_frame = ttk.Frame(self.scrollable_frame)
            service_frame.pack(fill=tk.X, pady=2)
            
            # ã‚µãƒ¼ãƒ“ã‚¹å
            name_label = ttk.Label(
                service_frame,
                text=service_state.name or service_key,
                width=15
            )
            name_label.pack(side=tk.LEFT, padx=(0, 10))
            
            # ã‚¹ã‚¤ãƒƒãƒ
            switch_callback = lambda enabled, key=service_key: self._on_service_toggle(key, enabled)
            
            if SLIDE_SWITCH_AVAILABLE:
                switch = SlideSwitch(
                    service_frame,
                    text="",
                    callback=switch_callback
                )
            else:
                switch = SlideSwitch(  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯SlideSwitchï¼ˆCheckbuttonï¼‰
                    service_frame,
                    text="æœ‰åŠ¹",
                    callback=switch_callback
                )
            
            switch.pack(side=tk.LEFT, padx=5)
            switch.set_state(service_state.enabled)
            
            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ãƒ™ãƒ«
            status_text = "ğŸŸ¢ æ¥ç¶šä¸­" if service_state.connected else "âš« åˆ‡æ–­ä¸­"
            status_color = "green" if service_state.connected else "red"
            
            status_label = ttk.Label(
                service_frame,
                text=status_text,
                foreground=status_color,
                width=10
            )
            status_label.pack(side=tk.LEFT, padx=(10, 0))
            
            # UIè¦ç´ ä¿å­˜
            self.service_switches[service_key] = switch
            self.status_labels[service_key] = status_label
            
            logger.debug(f"ğŸ¨ ã‚µãƒ¼ãƒ“ã‚¹UIä½œæˆ: {service_key}")
            
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹UIä½œæˆã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
    
    def _on_service_toggle(self, service_key: str, enabled: bool):
        """ã‚µãƒ¼ãƒ“ã‚¹ã‚¹ã‚¤ãƒƒãƒåˆ‡ã‚Šæ›¿ãˆ"""
        try:
            logger.info(f"ğŸ”„ ã‚µãƒ¼ãƒ“ã‚¹åˆ‡ã‚Šæ›¿ãˆ: {service_key} -> {'æœ‰åŠ¹' if enabled else 'ç„¡åŠ¹'}")
            
            # ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹æ›´æ–°
            if service_key in self.services:
                if SHARED_AVAILABLE:
                    safe_service_update(self.services[service_key], enabled=enabled)
                else:
                    self.services[service_key].update_state(enabled=enabled)
            
            # ğŸ†• ONECOMMEå°‚ç”¨: WebSocketManageråˆ¶å¾¡
            if service_key == ServiceKeys.ONECOMME and self.ws_manager:
                if enabled and not self.ws_started:
                    try:
                        self.ws_manager.start_background()
                        self.ws_started = True
                        logger.info("ğŸš€ WebSocketManager é–‹å§‹")
                        
                        # æ¥ç¶šçŠ¶æ…‹ã‚’æ›´æ–°
                        if SHARED_AVAILABLE:
                            safe_service_update(self.services[service_key], connected=True)
                        else:
                            self.services[service_key].update_state(connected=True)
                        
                    except Exception as e:
                        logger.error(f"âŒ WebSocketManager é–‹å§‹ã‚¨ãƒ©ãƒ¼: {e}")
                        enabled = False  # ã‚¹ã‚¤ãƒƒãƒã‚’æˆ»ã™
                        if service_key in self.service_switches:
                            self.service_switches[service_key].set_state(False)
                
                elif not enabled and self.ws_started:
                    try:
                        self.ws_manager.stop_background()
                        self.ws_started = False
                        logger.info("ğŸ›‘ WebSocketManager åœæ­¢")
                        
                        # æ¥ç¶šçŠ¶æ…‹ã‚’æ›´æ–°
                        if SHARED_AVAILABLE:
                            safe_service_update(self.services[service_key], connected=False)
                        else:
                            self.services[service_key].update_state(connected=False)
                        
                    except Exception as e:
                        logger.error(f"âŒ WebSocketManager åœæ­¢ã‚¨ãƒ©ãƒ¼: {e}")
            
            # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
            if service_key in self._connection_callbacks:
                try:
                    self._connection_callbacks[service_key](service_key, enabled)
                except Exception as e:
                    logger.error(f"âŒ ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
            
            # UIæ›´æ–°
            self._update_ui()
            
            # ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
            if self.message_bus and SHARED_AVAILABLE:
                try:
                    self.message_bus.publish(
                        Events.CONNECTION_STATUS_CHANGED,
                        {
                            'service': service_key,
                            'enabled': enabled,
                            'timestamp': time.time()
                        },
                        sender='ConnectionControlPanel'
                    )
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œè­¦å‘Š: {e}")
            
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹åˆ‡ã‚Šæ›¿ãˆã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
    
    def _update_ui(self):
        """UIè¡¨ç¤ºæ›´æ–°"""
        try:
            # ã‚µãƒãƒªãƒ¼æ›´æ–°
            if SHARED_AVAILABLE:
                summary = get_service_summary(self.services)
            else:
                enabled = sum(1 for s in self.services.values() if s.enabled)
                connected = sum(1 for s in self.services.values() if s.connected)
                summary = f"æœ‰åŠ¹: {enabled}/{len(self.services)}, æ¥ç¶š: {connected}/{len(self.services)}"
            
            self.summary_var.set(summary)
            
            # å„ã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            for service_key, service_state in self.services.items():
                if service_key in self.status_labels:
                    if service_state.connected:
                        status_text = "ğŸŸ¢ æ¥ç¶šä¸­"
                        status_color = "green"
                    elif service_state.enabled:
                        status_text = "ğŸŸ¡ æ¥ç¶šå¾…ã¡"
                        status_color = "orange"
                    else:
                        status_text = "âš« åˆ‡æ–­ä¸­"
                        status_color = "red"
                    
                    self.status_labels[service_key].config(
                        text=status_text,
                        foreground=status_color
                    )
            
        except Exception as e:
            logger.error(f"âŒ UIæ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _on_connection_status_changed(self, data: Dict[str, Any]):
        """æ¥ç¶šçŠ¶æ…‹å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†"""
        try:
            service_key = data.get('service')
            if service_key and service_key in self.services:
                # æ¥ç¶šçŠ¶æ…‹åæ˜ 
                connected = data.get('connected', False)
                if SHARED_AVAILABLE:
                    safe_service_update(self.services[service_key], connected=connected)
                else:
                    self.services[service_key].update_state(connected=connected)
                
                # UIæ›´æ–°
                self.after_idle(self._update_ui)
                
                logger.debug(f"ğŸ”„ æ¥ç¶šçŠ¶æ…‹å¤‰æ›´: {service_key} -> {'æ¥ç¶š' if connected else 'åˆ‡æ–­'}")
        
        except Exception as e:
            logger.error(f"âŒ æ¥ç¶šçŠ¶æ…‹å¤‰æ›´å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _on_service_error(self, data: Dict[str, Any]):
        """ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ©ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†"""
        try:
            service_key = data.get('service')
            error_msg = data.get('error', 'Unknown error')
            
            logger.warning(f"âš ï¸ ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ©ãƒ¼ ({service_key}): {error_msg}")
            
            # ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯æ¥ç¶šçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            if service_key and service_key in self.services:
                # ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã«è¨˜éŒ²
                error_time = time.time()
                
                # WebSocketé–¢é€£ã®ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯å†…éƒ¨çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆ
                if service_key == ServiceKeys.ONECOMME:
                    self.ws_started = False
                
                self.after_idle(self._update_ui)
            
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
    
    # === å…¬é–‹API ===
    
    def set_connection_callback(self, service_key: str, callback: Callable[[str, bool], None]):
        """æ¥ç¶šã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š"""
        self._connection_callbacks[service_key] = callback
        logger.debug(f"ğŸ”— ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š: {service_key}")
    
    def get_service_state(self, service_key: str) -> Optional[ServiceState]:
        """ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹å–å¾—"""
        return self.services.get(service_key)
    
    def get_all_services(self) -> Dict[str, ServiceState]:
        """å…¨ã‚µãƒ¼ãƒ“ã‚¹çŠ¶æ…‹å–å¾—"""
        return self.services.copy()
    
    def set_service_enabled(self, service_key: str, enabled: bool):
        """ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã®ã‚µãƒ¼ãƒ“ã‚¹æœ‰åŠ¹/ç„¡åŠ¹è¨­å®š"""
        try:
            if service_key in self.services:
                if SHARED_AVAILABLE:
                    safe_service_update(self.services[service_key], enabled=enabled)
                else:
                    self.services[service_key].update_state(enabled=enabled)
                
                # ã‚¹ã‚¤ãƒƒãƒUIæ›´æ–°
                if service_key in self.service_switches:
                    self.service_switches[service_key].set_state(enabled)
                
                self._update_ui()
                logger.info(f"ğŸ“ ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨­å®š: {service_key} -> {'æœ‰åŠ¹' if enabled else 'ç„¡åŠ¹'}")
            else:
                logger.warning(f"âš ï¸ å­˜åœ¨ã—ãªã„ã‚µãƒ¼ãƒ“ã‚¹: {service_key}")
                
        except Exception as e:
            logger.error(f"âŒ ã‚µãƒ¼ãƒ“ã‚¹è¨­å®šã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
    
    def set_service_connected(self, service_key: str, connected: bool):
        """ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã®æ¥ç¶šçŠ¶æ…‹è¨­å®š"""
        try:
            if service_key in self.services:
                if SHARED_AVAILABLE:
                    safe_service_update(self.services[service_key], connected=connected)
                else:
                    self.services[service_key].update_state(connected=connected)
                self._update_ui()
                logger.debug(f"ğŸ”Œ æ¥ç¶šçŠ¶æ…‹è¨­å®š: {service_key} -> {'æ¥ç¶š' if connected else 'åˆ‡æ–­'}")
            else:
                logger.warning(f"âš ï¸ å­˜åœ¨ã—ãªã„ã‚µãƒ¼ãƒ“ã‚¹: {service_key}")
                
        except Exception as e:
            logger.error(f"âŒ æ¥ç¶šçŠ¶æ…‹è¨­å®šã‚¨ãƒ©ãƒ¼ ({service_key}): {e}")
    
    def get_websocket_status(self) -> Dict[str, Any]:
        """WebSocketé–¢é€£ã®çŠ¶æ…‹å–å¾—"""
        try:
            status = {
                'websocket_manager_available': WEBSOCKET_MANAGER_AVAILABLE,
                'ws_manager_initialized': self.ws_manager is not None,
                'ws_started': self.ws_started,
                'onecomme_service_state': self.get_service_state(ServiceKeys.ONECOMME).to_dict() if ServiceKeys.ONECOMME in self.services else None
            }
            
            if self.ws_manager:
                try:
                    ws_status = self.ws_manager.get_status()
                    status['websocket_manager_status'] = ws_status
                except Exception as e:
                    status['websocket_manager_error'] = str(e)
            
            return status
            
        except Exception as e:
            logger.error(f"âŒ WebSocketçŠ¶æ…‹å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {'error': str(e)}
    
    def cleanup(self):
        """ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾"""
        try:
            # WebSocketManageråœæ­¢
            if self.ws_manager and self.ws_started:
                try:
                    self.ws_manager.stop_background()
                    self.ws_started = False
                    logger.info("ğŸ”Œ WebSocketManageråœæ­¢å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ WebSocketManageråœæ­¢è­¦å‘Š: {e}")
            
            # ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­è§£é™¤
            if self.message_bus:
                try:
                    self.message_bus.unsubscribe(
                        Events.CONNECTION_STATUS_CHANGED,
                        self._on_connection_status_changed
                    )
                    self.message_bus.unsubscribe(
                        Events.SERVICE_ERROR,
                        self._on_service_error
                    )
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­è§£é™¤è­¦å‘Š: {e}")
            
            # UIè¦ç´ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            self.service_switches.clear()
            self.status_labels.clear()
            self._connection_callbacks.clear()
            
            logger.info("ğŸ—‘ï¸ ConnectionControlPanel ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾å®Œäº†")
            
        except Exception as e:
            logger.error(f"âŒ ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾ã‚¨ãƒ©ãƒ¼: {e}")
    
    def destroy(self):
        """ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆç ´æ£„"""
        try:
            # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œ
            self.cleanup()
            
            # è¦ªã‚¯ãƒ©ã‚¹ã® destroy
            super().destroy()
            
        except Exception as e:
            logger.error(f"âŒ ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆç ´æ£„ã‚¨ãƒ©ãƒ¼: {e}")


# === ä¾¿åˆ©ãªä½œæˆé–¢æ•° ===

def create_connection_panel(parent, message_bus: Optional[MessageBus] = None, 
                          service_registry=None, **kwargs) -> ConnectionControlPanel:
    """
    ConnectionControlPanelä½œæˆä¾¿åˆ©é–¢æ•°ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰
    
    Args:
        parent: è¦ªã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆ
        message_bus: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒã‚¹
        service_registry: ã‚µãƒ¼ãƒ“ã‚¹ãƒ¬ã‚¸ã‚¹ãƒˆãƒª
        **kwargs: è¿½åŠ å¼•æ•°
        
    Returns:
        ConnectionControlPanel: ä½œæˆã•ã‚ŒãŸãƒ‘ãƒãƒ«
    """
    try:
        panel = ConnectionControlPanel(parent, message_bus, service_registry)
        logger.info("âœ… ConnectionControlPanelä½œæˆå®Œäº†ï¼ˆWebSocketé…ç·šçµ±åˆç‰ˆï¼‰")
        return panel
    except Exception as e:
        logger.error(f"âŒ ConnectionControlPanelä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
        raise


# === ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆä»»æ„ï¼‰ ===

if __name__ == "__main__":
    def test_callback(service_key: str, enabled: bool):
        logger.info(f"ğŸ”— ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯: {service_key} -> {'æœ‰åŠ¹' if enabled else 'ç„¡åŠ¹'}")
    
    # ãƒ†ã‚¹ãƒˆç”¨ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
    root = tk.Tk()
    root.title("ConnectionControlPanel WebSocketé…ç·šçµ±åˆç‰ˆãƒ†ã‚¹ãƒˆ")
    root.geometry("700x400")
    
    # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒã‚¹ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
    try:
        if SHARED_AVAILABLE:
            bus = get_message_bus()
        else:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ãƒŸãƒ¼ãƒã‚¹
            class DummyBus:
                def subscribe(self, event, callback): pass
                def publish(self, event, data, sender=None): pass
                def stop(self): pass
            bus = DummyBus()
    except Exception:
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ãƒŸãƒ¼ãƒã‚¹
        class DummyBus:
            def subscribe(self, event, callback): pass
            def publish(self, event, data, sender=None): pass
            def stop(self): pass
        bus = DummyBus()
    
    # ãƒ‘ãƒãƒ«ä½œæˆ
    panel = ConnectionControlPanel(root, bus)
    panel.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    # ãƒ†ã‚¹ãƒˆã‚µãƒ¼ãƒ“ã‚¹è¿½åŠ 
    test_services = {
        'onecomme': {'name': 'ã‚ã‚“ã‚³ãƒ¡', 'enabled': False, 'connected': False},
        'messagebus': {'name': 'MessageBus', 'enabled': True, 'connected': True},
        'voicevox': {'name': 'VOICEVOX', 'enabled': False, 'connected': False}
    }
    
    panel.update_services(test_services)
    
    # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š
    for key in test_services.keys():
        panel.set_connection_callback(key, test_callback)
    
    # WebSocketçŠ¶æ…‹è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    def show_websocket_status():
        try:
            status = panel.get_websocket_status()
            logger.info(f"ğŸ”Œ WebSocketçŠ¶æ…‹: {status}")
            root.after(5000, show_websocket_status)  # 5ç§’ã”ã¨
        except Exception as e:
            logger.error(f"âŒ WebSocketçŠ¶æ…‹è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: {e}")
    
    root.after(1000, show_websocket_status)
    
    try:
        logger.info("ğŸš€ ConnectionControlPanel WebSocketé…ç·šçµ±åˆç‰ˆãƒ†ã‚¹ãƒˆé–‹å§‹")
        root.mainloop()
    except Exception as e:
        logger.error(f"âŒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
    finally:
        try:
            panel.cleanup()
            if hasattr(bus, 'stop'):
                bus.stop()
        except:
            pass
        logger.info("âœ… ConnectionControlPanel WebSocketé…ç·šçµ±åˆç‰ˆãƒ†ã‚¹ãƒˆå®Œäº†")